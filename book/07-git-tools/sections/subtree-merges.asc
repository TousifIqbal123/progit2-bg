[[_subtree_merge]]
===== Subtree сливане

Идеята на subtree сливането е че имате два проекта и единия от тях съществува в поддиректория на другия.
Когато укажете subtree сливане, Git често е достатъчно добър да установи, че единия е поддърво на другия и слива съответно.

Ще видим пример за добавяне на отделен проект в съществуващ такъв и след това за сливане на код от втория в поддиректория на първия.

Първо, ще добавим приложението Rack към нашия проект.
Ще добавим Rack проекта като отдалечена референция в нашия собствен проект и след това ще го извлечем в негов собствен клон:

[source,console]
----
$ git remote add rack_remote https://github.com/rack/rack
$ git fetch rack_remote --no-tags
warning: no common commits
remote: Counting objects: 3184, done.
remote: Compressing objects: 100% (1465/1465), done.
remote: Total 3184 (delta 1952), reused 2770 (delta 1675)
Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.
Resolving deltas: 100% (1952/1952), done.
From https://github.com/rack/rack
 * [new branch]      build      -> rack_remote/build
 * [new branch]      master     -> rack_remote/master
 * [new branch]      rack-0.4   -> rack_remote/rack-0.4
 * [new branch]      rack-0.9   -> rack_remote/rack-0.9
$ git checkout -b rack_branch rack_remote/master
Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.
Switched to a new branch "rack_branch"
----

Сега имаме корена на Rack проекта в нашия клон `rack_branch` и нашия собствен проект в `master` клона.
Ако превключите единия и после другия, може да видите, че те имат различни корени:

[source,console]
----
$ ls
AUTHORS         KNOWN-ISSUES   Rakefile      contrib         lib
COPYING         README         bin           example         test
$ git checkout master
Switched to branch "master"
$ ls
README
----

Това е леко странна концепция.
Не е задължително всички клонове във вашето хранилище да са клонове от един и същи проект.
Не е често срещана ситуация, понеже рядко е полезна, но е сравнително лесно да имате клонове съдържащи изцяло различни истории.

В този случай, ние искаме да издърпаме Rack проекта в нашия `master` проект като поддиректория.
Можем да направим това с `git read-tree`.
Ще научим повече за тази команда и придружаващите я други в <<ch10-git-internals#ch10-git-internals>>, засега просто приемете, че тя прочита главното дърво на един клон в текущия индекс и работна директория.
Току що превключихме към `master` клона и издърпваме `rack_branch` клона в поддиректорията `rack` на нашия `master` клон за основния ни проект:

[source,console]
----
$ git read-tree --prefix=rack/ -u rack_branch
----

Когато къмитнем, изглежда имаме всички Rack файлове в тази поддиректория -- също както ако бяхме копирали директно вътре от архив.
Интересното в случая е, че можем сравнително лесно да сливаме промени от единия клон в другия.
Така, ако Rack проектът бъде обновен, можем да издърпаме upstream промените като превключим към този клон и стартираме издърпването:

[source,console]
----
$ git checkout rack_branch
$ git pull
----

След това, можем да слеем новите промени обратно в нашия `master` клон.
За да изтеглим промените и да попълним предварително къмит съобщението, използваме `--squash` опцията, както и `-Xsubtree` параметъра на recursive merge стратегията.
Рекурсивната стратегия се подразбира тук, но я указваме за яснота.

[source,console]
----
$ git checkout master
$ git merge --squash -s recursive -Xsubtree=rack rack_branch
Squash commit -- not updating HEAD
Automatic merge went well; stopped before committing as requested
----

Всички промени на Rack проекта са слети и са готови да се къмитнат локално.
Можете да направите и обратното -- да направите модификации в `rack` поддиректорията на `master` клона и след това да го слеете в `rack_branch` клона по-късно за да ги изпратите на собствениците на проекта.

Това ни дава възможност да следваме работен процес донякъде подобен на submodule без да използваме подмодули (което ще разгледаме в <<ch07-git-tools#_git_submodules>>).
В подобен маниер можем да пазим клонове с други свързани проекти в нашето хранилище и да ги интегрираме при необходимост в нашия собствен проект посредством subtree сливане.
В някои аспекти това е хубаво, защото целият код се къмитва на едно място.
От друга страна, един такъв подход си има и недостатъци, защото е малко по-сложен, по-лесно е да се правят грешки при повторна интеграция на промени и също така може по невнимание да се публикува погрешен клон в неподходящо хранилище.

Друго неудобство е, че за да получите diff между съдържанията на `rack` поддиректорията и кода в `rack_branch` клона (така че да разберете дали се налага да ги сливате) -- не можете да използвате нормалната `diff` команда.
Вместо това, трябва да използвате `git diff-tree` с клона, който искате да сравнявате:

[source,console]
----
$ git diff-tree -p rack_branch
----

Или, за да сравните съдържанието на `rack` поддиректорията със съдържанието на `master` клона на сървъра последния път когато сте го издърпали, може да изпълните:

[source,console]
----
$ git diff-tree -p rack_remote/master
----
